// Copyright (c) 2025 Milton McDonald
// This source code is licensed under the MIT License. See LICENSE file in the
// project root for details.

#include "graphics-engine/shader.h"

#include <algorithm>
#include <cassert>
#include <iostream>
#include <ranges>
#include <unordered_map>

#include "error.h"
#include "glad/glad.h"

using enum ::graphics_engine::types::ErrorCode;
using ::graphics_engine::error::MakeErrorCode;
using enum ::graphics_engine::shader::ShaderType;
using ::graphics_engine::types::Expected;

using ::std::cerr;
using ::std::is_same_v;
using ::std::string;
using ::std::to_underlying;
using ::std::unexpected;
using ::std::unordered_map;
using ::std::ranges::contains;
using ::std::views::keys;

static_assert(is_same_v<GLuint, unsigned int>,
              "GLuint and unsigned int are not the same type!");

namespace graphics_engine::shader {

namespace {

constexpr int kExpectedCount = 3;
static_assert(to_underlying(kNumShaderTypes) == kExpectedCount,
              "Add a new pair to kShaderTypeMap!");
static const unordered_map<ShaderType, GLenum> kShaderTypeMap = {
    {kFragment, GL_FRAGMENT_SHADER},
    {kGeometry, GL_GEOMETRY_SHADER},
    {kVertex, GL_VERTEX_SHADER}};

}  // namespace

auto CompileShader(unsigned int shader_id, const string& source_code)
    -> Expected<void> {
  const GLchar* source_code_cstr = source_code.c_str();
  glShaderSource(shader_id, 1, &source_code_cstr, nullptr);
  GLenum error = glGetError();
  if (error == GL_INVALID_VALUE) {
    cerr << shader_id << " is not a value generated by OpenGL\n";
    return unexpected(MakeErrorCode(kGLErrorInvalidValue));
  }

  glCompileShader(shader_id);
  assert(glGetError() == GL_NO_ERROR);

  GLint compile_status{};
  glGetShaderiv(shader_id, GL_COMPILE_STATUS, &compile_status);
  assert(glGetError() == GL_NO_ERROR);
  
  if (compile_status == GL_FALSE) {
    GLint info_log_length{};
    glGetShaderiv(shader_id, GL_INFO_LOG_LENGTH, &info_log_length);
    assert(glGetError() == GL_NO_ERROR);

    string info_log(info_log_length, '\0');
    glGetShaderInfoLog(shader_id, info_log_length, nullptr, info_log.data());
    assert(glGetError() == GL_NO_ERROR);

    cerr << "Shader compilation failed: " << info_log << '\n';
    return unexpected(MakeErrorCode(kShaderCompilationFailure));
  }

  assert(compile_status == GL_TRUE);

  return {};
}

auto CreateShader(ShaderType type) -> Expected<unsigned int> {
  const auto& acceptable_keys = keys(kShaderTypeMap);
  if (!contains(acceptable_keys, type))
    return unexpected(MakeErrorCode(kInvalidShaderType));

  GLuint shader = glCreateShader(kShaderTypeMap.at(type));
  assert(glGetError() == GL_NO_ERROR);
  assert(shader > 0);

  return shader;
}

}  // namespace graphics_engine::shader
